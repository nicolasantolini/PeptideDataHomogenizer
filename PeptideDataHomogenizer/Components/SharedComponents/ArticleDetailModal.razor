@using Entities
@using Entities.RegexData
@using Microsoft.AspNetCore.Identity
@using PeptideDataHomogenizer.Data
@using PeptideDataHomogenizer.Services
@using PeptideDataHomogenizer.Tools
@using PeptideDataHomogenizer.Tools.HtmlTools
@using PeptideDataHomogenizer.Tools.RegexExtractors
@using SuperSimpleBlazorModal
@using System.Text
@using System.Text.RegularExpressions
@using iTextSharp

@inject IFullArticleDownloader FullArticleDownloader
@inject ArticleExtractorFromHtml ArticleExtractorFromHtml
@inject DatabaseDataHandler DatabaseDataHandler
@inject ArticleService ArticleService
@inject ArticleContentService ArticleContentService
@inject ArticleModerationService ArticleModerationService
@inject ArticlePerProjectService ArticlePerProjectService
@inject ProteinDataService ProteinDataService
@inject ProteinDataPerProjectService ProteinDataPerProjectService
@inject PDBRecordsExtractor PDBRecordsExtractor
@inject IPageFetcher PageFetcher
@inject UserManager<ApplicationUser> UserManager
@inject AuthenticationStateProvider AuthenticationStateProvider

<SimpleModal @ref="modal"
Id="article-detail-modal"
OnModalStateChange="HandleModalStateChange"
OpenOnFirstRender="true">

    @if (isLoading)
    {
        <div class="loading-progress">
            <div class="spinner"></div>
            <p>Loading...</p>
        </div>
    }
    else{
    <div class="modal-header sticky-modal-header @(ArticlePerProject?.IsDiscredited == true ? "discredited-header" : "")">
            <style>
            .discredited-header {
                background-color: #ffcccc !important;
            }
            .discredited-body {
                background-color: #ffcccc !important;
            }
            .already-working-message {
                background: linear-gradient(90deg, #f7b42c 0%, #fc575e 100%);
                color: #fff;
                font-weight: 600;
                border-radius: 8px;
                padding: 0.5rem 1.2rem;
                margin-bottom: 0.75rem;
                font-size: 1.08rem;
                box-shadow: 0 2px 8px rgba(252,87,94,0.08);
                display: flex;
                align-items: center;
                gap: 0.5rem;
                max-width: 90%;
            }
            .already-working-message svg {
                flex-shrink: 0;
            }
            </style>
            @if (Article?.ProteinData != null && Article.ProteinData.Any() && Article.ProteinData.All(pd => pd.Id != 0) && !ArticlePerProject.IsApproved)
            {
                <div class="already-working-message">
                    <svg width="22" height="22" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M10 2a8 8 0 100 16 8 8 0 000-16zm.75 11.5a.75.75 0 01-1.5 0v-1a.75.75 0 011.5 0v1zm0-2.75a.75.75 0 01-1.5 0V7a.75.75 0 011.5 0v3.75z"/>
                    </svg>
                    Someone was already working on this article...
                </div>
            }
            <div style="max-width: calc(100% - 150px);">
                <h5 class="modal-title text-wrap pe-2">@Article.Title @(ArticlePerProject?.IsDiscredited == true ? "DISCREDITED" : "")</h5>
            </div>
            <div class="d-flex gap-1">
                <button type="button" disabled="@(ArticlePerProject.IsDiscredited)" class="btn btn-sm btn-primary" @onclick="ExtractProteinData">
                    Extract Protein Data
                </button>
                <button type="button" disabled="@(ArticlePerProject.IsDiscredited)" class="btn btn-sm btn-primary" @onclick="CompleteArticle">
                    Mark Article as Complete
                </button>
                <button type="button" disabled="@(ArticlePerProject.IsDiscredited)" class="btn btn-sm btn-danger" @onclick="ShowDiscreditModal">
                    Discredit
                </button>
                <OtherProjectsProtein OtherProjectsProteinData="@otherProjectsProteinData" OnDataCopied="ReplaceProteinData"></OtherProjectsProtein>
                <label class="btn btn-sm btn-outline-primary d-flex align-items-center" for="pdfUpload">
                    <svg width="16" height="16" fill="currentColor" class="me-1" viewBox="0 0 16 16">
                        <path d="M8 6.5a.5.5 0 0 1 .5.5v3.793l1.146-1.147a.5.5 0 0 1 .708.708l-2 2a.5.5 0 0 1-.708 0l-2-2a.5.5 0 1 1 .708-.708L7.5 10.793V7a.5.5 0 0 1 .5-.5z"/>
                        <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h6.5L14 4.5zm-3-.5V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V5h-3.5A1.5 1.5 0 0 1 11 4z"/>
                    </svg>
                    Upload PDF
                </label>
                <InputFile disabled="@(ArticlePerProject.IsDiscredited)" id="pdfUpload" style="display:none" OnChange="HandlePdfUpload" accept=".pdf" />
                
                    <button type="button"
                            class="btn btn-lg btn-danger modal-close-btn"
                            @onclick="Close"
                            aria-label="Close">
                        &times;
                    </button>
            </div>
        </div>

        <div class="modal-body @(ArticlePerProject.IsDiscredited ? "discredited-body" : "")">
            <div class="row mb-3">
                <div class="col-md-6">
                    <p><strong>Journal:</strong> @Article.Journal</p>
                    <p>
                        <strong>DOI:</strong>
                        @if (!string.IsNullOrEmpty(Article.Doi))
                        {
                            <a href="https://doi.org/@Article.Doi" target="_blank">@Article.Doi</a>
                        }
                        else
                        {
                            <span>Not available</span>
                        }
                    </p>
                    <p>
                        <strong>Publication Date:</strong>
                        @if (Article.PublicationDate!=null)
                        {
                            <span>@Article.PublicationDate.ToString("dd-MM-yyyy")</span>
                        }
                        else
                        {
                            <span>Not available</span>
                        }
                    </p>
                </div>
                <div class="col-md-6">
                    <p><strong>Authors:</strong></p>
                    <p>@Article.Authors</p>
                </div>
            </div>

            <div class="abstract-section mb-3">
                <h6>Abstract</h6>
                <p class="abstract-text">@Article.Abstract</p>
            </div>

            

        @if (Article.ProteinData.Any())
        {
                <ProteinTable ProteinData="Article.ProteinData"
                              NewProtein="newProtein"
                              RemoveProtein="(protein) => RemoveProtein(protein)"
                              AddProtein="AddProtein"
                              HighlightText="async (term, termCategory) => await HighlightText(term, termCategory)" 
                              OnConversionConfirmed="@(args => ConvertValue(args.proteinId, args.index, args.value))"/>
            <div class="mt-2">
                <button class="btn btn-outline-primary" @onclick="UpdateArticleProteinData">
                    Update All Protein Data
                </button>

                <button class="btn btn-outline-success" @onclick="ToggleApproveAllProteins" style="transition: background 0.2s, color 0.2s;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" class="me-2" viewBox="0 0 16 16">
                        @if (AreAllProteinsApproved())
                        {
                            <path d="M2 8a6 6 0 1112 0A6 6 0 012 8zm9.354-2.646a.5.5 0 00-.708-.708L7 8.293 5.354 6.646a.5.5 0 10-.708.708l2 2a.5.5 0 00.708 0l4-4z" />
                        }
                        else
                        {
                            <path d="M8 15A7 7 0 108 1a7 7 0 000 14zm3.354-8.646a.5.5 0 00-.708-.708L7 9.293 5.354 7.646a.5.5 0 10-.708.708l2 2a.5.5 0 00.708 0l4-4z" />
                        }
                    </svg>
                    @if (AreAllProteinsApproved())
                    {
                        <span>Unmark All as Approved</span>
                    }
                    else
                    {
                        <span>Mark All as Approved</span>
                    }
            </button>

            @code {
                private void ToggleApproveAllProteins()
                {
                    if (Article?.ProteinData == null) return;
                    bool approve = !AreAllProteinsApproved();
                    foreach (var protein in Article.ProteinData)
                    {
                        protein.Approved = approve;
                    }
                }

                private bool AreAllProteinsApproved()
                {
                    return Article?.ProteinData != null && Article.ProteinData.Any() && Article.ProteinData.All(p => p.Approved);
                }
            }

            <ProteinCombinationGenerator Article="@Article" ArticleChanged="@(async (updatedArticle) => { Article = updatedArticle; await InvokeAsync(StateHasChanged); })"></ProteinCombinationGenerator>
            <ProteinDataDeleter Article="Article" ArticleChanged="@(async (updatedArticle) => { Article = updatedArticle; await InvokeAsync(StateHasChanged); })"></ProteinDataDeleter>
        </div>
                }

        <ul class="nav nav-tabs">
            <li class="nav-item">
                <a class="nav-link @(activeTab == "content" ? "active" : "")" href="#" @onclick="() => SetActiveTab(1)">Full Text & Data</a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(activeTab == "tables" ? "active" : "")" href="#" @onclick="() => SetActiveTab(2)">Tables</a>
            </li>
            <li class="nav-item">
                <a class="nav-link @(activeTab == "images" ? "active" : "")" href="#" @onclick="() => SetActiveTab(3)">Images</a>
            </li>
        </ul>
            <div class="tab-content">
                <div id="content" class="fulltext-section tab-pane @(activeTab == "content" ? "active show" : "fade")">

                    

                

                @if (Article.Chapters != null)
                {
                    <div class="position-relative">
                        <div class="highlight-nav position-absolute top-0 end-0 mt-2 me-4">
                            <button class="btn btn-sm btn-light" @onclick="PrevHighlight">
                                &lt;
                            </button>
                            <span class="mx-2">@(currentHighlightIndex + 1)/@highlightCount</span>
                            <button class="btn btn-sm btn-light" @onclick="NextHighlight">
                                &gt;
                            </button>

                            <div class="d-flex flex-column align-items-start mt-2">
                                @if (termCategory != -1)
                                {
                                    <button class="btn btn-sm btn-danger m-2" @onclick="() => RemoveInvalidRecords(searchTerm, termCategory)">
                                        Remove All with '@searchTerm' (@keyValuePairs[termCategory])
                                    </button>
                                }
                                @if (termCategory == 0 && !searchTerm.Contains("fold", StringComparison.InvariantCultureIgnoreCase))
                                {
                                    <button class="btn btn-sm btn-info m-2" @onclick="() => OpenRCSB(searchTerm)">
                                        Open RCSB for '@searchTerm'
                                    </button>
                                    <button class="btn btn-sm btn-info m-2" @onclick="() => OpenMolStarViewer(searchTerm)">
                                        Open Mol* Viewer for '@searchTerm'
                                    </button>
                                    
                                }
                        </div>
                        @code {

                            private string selectedMolStarPDBId = "";
                            private void OpenMolStarViewer(string searchTerm)
                            {
                                if (string.IsNullOrEmpty(searchTerm)) return;
                                // Check if the search term is a valid PDB ID
                                if (Regex.IsMatch(searchTerm, @"^[1-9][A-Za-z0-9]{3}$"))
                                {
                                    selectedMolStarPDBId = searchTerm;
                                    StateHasChanged();
                                }
                                else
                                {
                                    JSRuntime.InvokeVoidAsync("alert", "Invalid PDB ID format. Please enter a valid 4-character PDB ID.");
                                }
                            }
                            private void OnCloseMolStarViewer()
                            {
                                selectedMolStarPDBId = "";
                            }
                            public async Task OpenRCSB(string searchTerm)
                            {
                                var url = $"https://www.rcsb.org/structure/{searchTerm}";
                                await JSRuntime.InvokeVoidAsync("open", url, "_blank");
                            }

                        }

                        @if (termCategory != -1)
                        {
                            <div class="mt-2 d-flex align-items-center">
                                <span class="me-2">Replace with:</span>
                                @switch (termCategory)
                                {
                                    case 5: // Temperature
                                    case 7: // Ion Concentration
                                    case 8: // Simulation Length
                                            <input type="number" step="0.01" class="form-control form-control-sm me-2" style="width: 120px;"
                                                   @bind="replacementValue" />
                                        break;
                                    default: // String fields
                                             <input type="text" class="form-control form-control-sm me-2" style="width: 150px;"
                                                    @bind="replacementValueText" />
                                        break;
                                }
                                <button class="btn btn-sm btn-warning" @onclick="() => UpdateMatchingRecords(searchTerm, termCategory)">
                                    Apply
                                </button>
                            </div>
                        }

                                @code {


                            private double replacementValue;
                            private string replacementValueText = "";

                            private async Task UpdateMatchingRecords(string term, int termCategory)
                            {
                            if (Article?.ProteinData == null) return;

                            switch (termCategory)
                            {

                                case 0: // Protein ID
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.ProteinId) || p.ProteinId.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.ProteinId = replacementValueText;
                                    }
                                    break;
                                case 1: // Software Name
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.SoftwareName) || p.SoftwareName.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.SoftwareName = replacementValueText;
                                    }
                                    break;
                                case 2: // Water Model
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.WaterModel) || p.WaterModel.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.WaterModel = replacementValueText;
                                    }
                                    break;
                                case 3: // Force Field
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.ForceField) || p.ForceField.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.ForceField = replacementValueText;
                                    }
                                    break;
                                case 4: // SimulationMethod
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.SimulationMethod) || p.SimulationMethod.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.SimulationMethod = replacementValueText;
                                    }
                                    break;
                                case 5: // Temperature
                                    if (double.TryParse(term, out double temp))
                                    {
                                        foreach (var protein in Article.ProteinData.Where(p => p.Temperature == temp))
                                        {
                                            protein.Temperature = replacementValue;
                                        }
                                    }
                                    break;
                                case 6: // Ions
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.Ions) || p.Ions.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.Ions = replacementValueText;
                                    }
                                    break;
                                case 7: // Ion Concentration
                                    if (double.TryParse(term, out double ionConcentration))
                                    {
                                        foreach (var protein in Article.ProteinData.Where(p => p.IonConcentration == ionConcentration))
                                        {
                                            protein.IonConcentration = replacementValue;
                                        }
                                    }
                                    break;
                                case 8: // Simulation Length
                                    if (double.TryParse(term, out double simulationLength))
                                    {
                                        foreach (var protein in Article.ProteinData.Where(p => p.SimulationLength == simulationLength))
                                        {
                                            protein.SimulationLength = replacementValue;
                                        }
                                    }
                                    break;

                                case 9: // Software Version
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.SoftwareVersion) || p.SoftwareVersion.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.SoftwareVersion = replacementValueText;
                                    }
                                    break;

                                case 10: // Residue
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.Residue) || p.Residue.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.Residue = replacementValueText;
                                    }
                                    break;
                                case 11: // Binder
                                    foreach (var protein in Article.ProteinData
                                    .Where(p => string.IsNullOrEmpty(p.Binder) || p.Binder.Equals(term, StringComparison.OrdinalIgnoreCase)))
                                    {
                                        protein.Binder = replacementValueText;
                                    }
                                    break;

                            }

                            // Reset the search term to clear highlighting
                            string oldSearchTerm = searchTerm;
                            searchTerm = "";
                            ProcessTextForHighlighting();

                            // Notify user of successful update
                            await JSRuntime.InvokeVoidAsync("alert", $"Updated all {keyValuePairs[termCategory]} values from '{oldSearchTerm}' to '{(termCategory == 5 || termCategory == 7 || termCategory == 8 ? replacementValue.ToString() : replacementValueText)}'");

                            // Reset replacement values
                            replacementValueText = "";
                            replacementValue = 0;

                            await InvokeAsync(StateHasChanged);

                            }
                        }
                    </div>


                    <div class="d-flex justify-content-center align-items-center mb-3">
                        <div class="form-check me-2" style="justify-content:center">
                            <input type="checkbox" class="form-check-input m-2" style="position:relative;top:5px" id="ignoreCaseCheckbox" @bind="ignoreCase" />
                            <label class="form-check m-2">Ignore Case</label>
                        </div>
                        <input type="text"
                               class="form-control me-2"
                               style="max-width: 300px;"
                               placeholder="Search full text..."
                               @bind="searchTerm"
                               @bind:event="oninput" />
                        <button class="btn btn-primary"
                                @onclick="() => HighlightText(searchTerm, -1)">
                            Highlight
                        </button>
                    </div>

                    @code {
                        private bool ignoreCase = true;
                    }

                    <div class="article-fulltext-container">
                        @foreach (var chapter in processedChapters)
                        {
                            <div class="chapter-section position-relative">
                                @if (!string.IsNullOrWhiteSpace(chapter.Title))
                                {
                                    <div class="d-flex align-items-center justify-content-between mb-2">
                                        <div class="chapter-title">@chapter.Title</div>
                                        <button class="btn btn-outline-danger btn-sm chapter-remove-btn"
                                                title="Remove this chapter"
                                                @onclick="() => DeleteChapter(chapter.Title)">
                                            <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="none" viewBox="0 0 24 24">
                                                <circle cx="12" cy="12" r="12" fill="#fff" />
                                                <path d="M15.5 8.5l-7 7M8.5 8.5l7 7" stroke="#dc3545" stroke-width="2" stroke-linecap="round" />
                                            </svg>
                                            <span class="visually-hidden">Remove</span>
                                        </button>
                                    </div>
                                }
                                <div class="chapter-content">
                                    @foreach (var fragment in chapter.Fragments)
                                    {
                                        if (fragment.IsMatch)
                                        {
                                            <span class="@fragment.Classes" data-index="@fragment.MatchIndex">@fragment.Text</span>
                                        }
                                        else
                                        {
                                            <span>@fragment.Text</span>
                                        }
                                    }
                                </div>
                            </div>
                        }
                    </div>
                </div>
                }
                else
                {
                    <p>No full text available.</p>
                }

                <style>
                    .article-fulltext-container {
                        padding: 1.5rem;
                        font-family: 'Georgia', 'Times New Roman', Times, serif;
                        font-size: 1.08rem;
                        line-height: 1.7;
                        background: #f9fafb;
                        border-radius: 0.5rem;
                        box-shadow: 0 2px 12px rgba(0,0,0,0.04);
                        max-height: 60vh;
                        overflow-y: auto;
                        max-width: 60%;
                        margin: 0 auto;
                    }

                    .chapter-section {
                        margin-bottom: 3rem;
                        padding: 0 0.5rem;
                        border-bottom: 1px solid #e0e0e0;
                    }

                        .chapter-section:last-child {
                            border-bottom: none;
                        }

                    .chapter-title {
                        font-family: 'Merriweather', 'Georgia', serif;
                        font-size: 1.35rem;
                        font-weight: 700;
                        color: #2a3b4c;
                        margin-top: 0.5rem;
                        margin-bottom: 1rem;
                        letter-spacing: 0.01em;
                        text-shadow: 0 1px 0 #fff;
                    }

                    .chapter-content p {
                        margin-bottom: 1.1em;
                        text-align: justify;
                        text-justify: inter-word;
                    }

                    @@media (max-width: 900px) {
                        .article-fulltext-container {
                            font-size: 1rem;
                            padding: 1rem 0.2rem;
                        }

                        .chapter-title {
                            font-size: 1.1rem;
                        }
                    }
                </style>
                </div>
                <div id="tables" class="tab-pane @(activeTab == "tables" ? "active show" : "fade")">
                    <TablesManager Tables="(List<ExtractedTable>) Article.Tables"></TablesManager>
                </div>
                <div id="images" class="tab-pane @(activeTab == "images" ? "active show" : "fade")">
                    <ImagesManager Images="(List<ImageHolder>) Article.Images"></ImagesManager>
                </div>
            </div>

            @code {

            private Dictionary<int,string> tabNames = new Dictionary<int, string>
                {
                    { 1, "content" },
                    { 2, "tables" },
                    { 3, "images" }
                };

                private string activeTab = "content";

                private void SetActiveTab(int tabIndex)
                {
                activeTab = tabNames.ContainsKey(tabIndex) ? tabNames[tabIndex] : "content";
                StateHasChanged();
                }
            }
        </div>

        <div class="modal-footer">
            <button class="btn btn-secondary" @onclick="Close">Close</button>
        </div>
        }
    
</SimpleModal>

<FullScreenMolStarPDBViewver pdbId="@selectedMolStarPDBId" OnClose="OnCloseMolStarViewer"></FullScreenMolStarPDBViewver>

<style>
.upload-label {
    cursor: pointer;
    background: #f8f9fa;
    border-radius: 50%;
    padding: 0.3rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    transition: background 0.2s;
    display: inline-block;
}
.upload-label:hover {
    background: #e2e6ea;
}
.upload-icon {
    color: #007bff;
    display: flex;
    align-items: center;
    justify-content: center;
}
</style>

<SimpleModal @ref="discreditModal"
             Id="discredit-modal"
             OnModalStateChange="() => {}"
             OpenOnFirstRender="false">
    <div class="modal-header">
        <h5 class="modal-title">Discredit Article: @Article?.Title</h5>
        <button type="button" class="btn-close" @onclick="CloseDiscreditModal"><i class="bi bi-x-lg"></i></button>
    </div>
    <div class="modal-body">
        <div class="mb-3">
            <label class="form-label">Discredit Reason:</label>
            <textarea class="form-control" rows="4" @bind="discreditReason"></textarea>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-secondary" @onclick="CloseDiscreditModal">Cancel</button>
        <button class="btn btn-danger" @onclick="SaveDiscredit">Confirm Discredit</button>
    </div>
</SimpleModal>



@code {
    private SimpleModal? modal;

    [Parameter]
    public Article? Article { get; set; }

    [Parameter]
    public ArticlePerProject? ArticlePerProject { get; set; }

    [Parameter]
    public EventCallback<bool> OnModalStateChange { get; set; }

    private SimpleModal? discreditModal;
    private string discreditReason = "";
    private ProteinData newProtein = new ProteinData();

    private Dictionary<Project, List<ProteinData>> otherProjectsProteinData = new Dictionary<Project, List<ProteinData>>();
    private int otherProjectProteinDataSelectedId = 0;

    private ApplicationUser? currentUser;

    private Dictionary<int,string> keyValuePairs = new Dictionary<int, string>
    {
        {-1, "General"},
        { 0, "Protein ID" },
        { 1, "Software Name" },
        { 2, "Water Model" },
        { 3, "Force Field" },
        { 4, "SimulationMethod" },
        { 5, "Temperature (K)" },
        { 6, "Ions" },
        { 7, "Ion Concentration (M)" },
        { 8, "Simulation Length (ns)" },
        { 9, "Software Version"},
        { 10 , "Residue"},
        { 11, "Binder"  }
    };

    // Highlighting system
    private string searchTerm = "";
    private int termCategory = -1; 
    private int currentHighlightIndex = -1;
    private List<ChapterDisplay> processedChapters = new();
    private int highlightCount = 0;

    private bool isLoading = true;

    protected override async Task OnParametersSetAsync()
    {

        if (ArticlePerProject!=null)
        {
            isLoading = true;
            otherProjectsProteinData = await ProteinDataPerProjectService.GetProteinDataPerProjectAsync(Article.Doi);
            var project = await DatabaseDataHandler.GetByIdAsync<Project>(ArticlePerProject.ProjectId);

            //if project is in otherProjectsProteinData, remove it (check by project.Id))
            if (project != null && otherProjectsProteinData.Keys.Select(p => p.Id).ToList().Contains(project.Id))
            {
                otherProjectsProteinData = otherProjectsProteinData
                    .Where(kvp => kvp.Key.Id != project.Id)
                    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
            }
            else
            {
                // Handle the case where the project is null
                Console.WriteLine("Project not found for the given ProjectId.");
            }
            currentUser = await UserManager.GetUserAsync((await AuthenticationStateProvider.GetAuthenticationStateAsync()).User);

            ProcessTextForHighlighting();
            isLoading = false;
        }
        isLoading = false;
    }

    //on data copied event handler
    private async Task ReplaceProteinData(List<ProteinData> proteinData)
    {
        isLoading = true;
        proteinData.ForEach(pd=>pd.ArticleDoi = Article.Doi);
        proteinData.ForEach(pd => pd.ProjectId = ArticlePerProject.ProjectId);  
        Article.ProteinData = proteinData.ToList();
        isLoading = false;
        await InvokeAsync(StateHasChanged);

    }

    private async Task HandleModalStateChange(bool isOpen)
    {
        await OnModalStateChange.InvokeAsync(isOpen);

    }

    private async Task OpenLink(string url)
    {
        await Close();
        await JSRuntime.InvokeVoidAsync("window.open", url, "_blank");
    }


    private async Task HandlePdfUpload(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null || !file.Name.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
            return;

        // Allow up to 100 MB
        const long maxFileSize = 100 * 1024 * 1024;
        if (file.Size > maxFileSize)
        {
            // Optionally show error to user
            return;
        }
        isLoading = true;

        using var stream = file.OpenReadStream(maxFileSize);
        using var ms = new MemoryStream();
        await stream.CopyToAsync(ms);
        var pdfBytes = ms.ToArray();

        // Convert PDF bytes to HTML
        try
        {
            var htmlFromPDF = ChapterExtractor.ExtractWithPdfPig(pdfBytes);

            var extractedData = await ArticleExtractorFromHtml.ExtractChaptersImagesAndTables(htmlFromPDF,Article.Title,"");
            var chapters = extractedData.Item1;
            chapters.ForEach(c => c.ArticleDoi = Article.Doi);
            await ArticleContentService.ReplaceChaptersAsync(chapters,Article.Doi);
            Article.Chapters = chapters;


            Article.Tables = extractedData.Item2;
            Article.Tables.ForEach(t => t.ArticleDoi = Article.Doi);
            await ArticleContentService.ReplaceTablesAsync(Article.Tables,Article.Doi);
            Article.Images = extractedData.Item3;
            Article.Images.ForEach(i => i.ArticleDoi = Article.Doi);
            await ArticleContentService.ReplaceImagesAsync(Article.Images, Article.Doi);


            await ExtractProteinData();

            ProcessTextForHighlighting();
            isLoading = false;

            await InvokeAsync(StateHasChanged);

        }
        catch (Exception ex)
        {
            // Handle conversion errors
            isLoading = false;
            await JSRuntime.InvokeVoidAsync("alert",$"Error converting PDF to HTML: {ex}");
        }
    }

    private async Task ExtractProteinData()
    {
        isLoading = true;
        var fullText = string.Join("\n\n", Article.Chapters.Select(c => c.Content));

        List<string> KnownSoftwareNames = new List<string>();
        List<string> ImplicitWaterNames = new List<string>();
        List<string> ExplicitWaterNames = new List<string>();
        List<string> KnownForceFields = new List<string>();
        List<string> KnownMethods = new List<string>();
        List<string> KnownIons = new List<string>();

        var simulationSoftwares = await DatabaseDataHandler.GetAllAsync<SimulationSoftware>();
        KnownSoftwareNames = simulationSoftwares.Select(x => x.SoftwareName).ToList();

        var waterModels = await DatabaseDataHandler.GetAllAsync<WaterModel>().ConfigureAwait(false);
        ImplicitWaterNames = waterModels.Where(wm => wm.WaterModelType == "implicit").Select(wm => wm.WaterModelName).ToList();
        ExplicitWaterNames = waterModels.Where(wm => wm.WaterModelType == "explicit").Select(wm => wm.WaterModelName).ToList();

        var forceFields = await DatabaseDataHandler.GetAllAsync<ForceFieldSoftware>().ConfigureAwait(false);
        KnownForceFields = forceFields.Select(ff => ff.SoftwareName).ToList();

        var methods = await DatabaseDataHandler.GetAllAsync<SimulationMethod>().ConfigureAwait(false);
        KnownMethods = methods.Select(m => m.MethodName).ToList();

        var ions = await DatabaseDataHandler.GetAllAsync<Ion>().ConfigureAwait(false);
        KnownIons = ions.Select(i => i.IonName).ToList();


        Article.ProteinData = await PDBRecordsExtractor.ExtractMdData(fullText,KnownSoftwareNames,ImplicitWaterNames,ExplicitWaterNames,KnownForceFields,KnownMethods,KnownIons);

        var pdbIds = Article.ProteinData.Select(pd => pd.ProteinId)
                        .Where(id => !string.IsNullOrEmpty(id) && !id.Contains("AlphaFold", StringComparison.InvariantCultureIgnoreCase) && !id.Contains("RosettaFold", StringComparison.InvariantCultureIgnoreCase))
                        .Distinct()
                        .ToList();
        Console.WriteLine($"[LOOP] Found {pdbIds.Count} unique PDB IDs for DOI={Article.Doi}");

        var extractTasks = pdbIds
            .ToDictionary(
                pdbId => pdbId,
                pdbId => PageFetcher.ExtractClassificationOrganismAndMethodAsync(pdbId)
            );

        Console.WriteLine($"[LOOP] Awaiting {extractTasks.Count} ExtractClassificationOrganismAndMethodAsync tasks for DOI={Article.Doi}");
        await Task.WhenAll(extractTasks.Values).ConfigureAwait(false);
        PageFetcher.Dispose();

        var pdbIdToInfo = new Dictionary<string, (string classification, string organism, string method)>();

        foreach (var kvp in extractTasks)
        {
            var pdbId = kvp.Key;
            var results = await kvp.Value;
            var valid = results.FirstOrDefault(r =>
                !string.Equals(r.Item1, "Not found", StringComparison.OrdinalIgnoreCase) ||
                !string.Equals(r.Item2, "Not found", StringComparison.OrdinalIgnoreCase) ||
                !string.Equals(r.Item3, "Not found", StringComparison.OrdinalIgnoreCase)
            );
            if (
                string.Equals(valid.Item1, "Not found", StringComparison.OrdinalIgnoreCase) &&
                string.Equals(valid.Item2, "Not found", StringComparison.OrdinalIgnoreCase) &&
                string.Equals(valid.Item3, "Not found", StringComparison.OrdinalIgnoreCase)
            )
            {
                pdbIdToInfo[pdbId] = ("Not found", "Not found", "Not found");
            }
            else
            {
                pdbIdToInfo[pdbId] = valid;
            }
        }
        Console.WriteLine($"[LOOP] Classification/organism/method info extracted for {pdbIdToInfo.Count} PDB IDs for DOI={Article.Doi}");

        // Set classification, organism, method if at least one is valid
        foreach (var pd in Article.ProteinData)
        {
            if (pdbIdToInfo.TryGetValue(pd.ProteinId, out var info))
            {
                if (!string.Equals(info.classification, "Not found", StringComparison.OrdinalIgnoreCase))
                    pd.Classification = info.classification;
                if (!string.Equals(info.organism, "Not found", StringComparison.OrdinalIgnoreCase))
                    pd.Organism = info.organism;
                if (!string.Equals(info.method, "Not found", StringComparison.OrdinalIgnoreCase))
                    pd.Method = info.method;
            }
        }

        // Remove ProteinData with all empty or whitespace for classification, method, and organism
        int beforeFilter = Article.ProteinData.Count;
        Article.ProteinData = Article.ProteinData
            .Where(pd =>
                !string.IsNullOrWhiteSpace(pd.Classification) ||
                !string.IsNullOrWhiteSpace(pd.Method) ||
                !string.IsNullOrWhiteSpace(pd.Organism)
            )
            .ToList();


        int afterFilter = Article.ProteinData.Count;
        Console.WriteLine($"[LOOP] Filtered protein data for DOI={Article.Doi}: {beforeFilter} -> {afterFilter} records");

        isLoading=false;
        await InvokeAsync(StateHasChanged);
    }


    private void ShowDiscreditModal()
    {
        discreditReason = ArticlePerProject.DiscreditedReason;
        discreditModal?.ShowModal();
    }

    private void CloseDiscreditModal()
    {
        discreditModal?.CloseModal();
    }

    private async Task UpdateArticleProteinData()
    {
        if (Article == null || Article.ProteinData == null)
            return;
        isLoading = true;
        await ProteinDataService.SaveOrUpdateProteinDataListAsync(Article.ProteinData.ToList(),Article.Doi,ArticlePerProject.ProjectId);
        isLoading = false;
    }

    private async Task SaveDiscredit()
    {
        CloseDiscreditModal();        
        await modal?.CloseModal();

        isLoading = true;
        ArticlePerProject.IsDiscredited = true;
        ArticlePerProject.ApprovedById = currentUser.Id;
        await ArticleModerationService.DiscreditArticleInProjectAsync(ArticlePerProject.ProjectId,Article.Doi, discreditReason);
        Article.Chapters = new List<Chapter>();
        Article.ProteinData = new List<ProteinData>();
        isLoading = false;

    }

    private void AddProtein()
    {
        if (string.IsNullOrWhiteSpace(newProtein.ProteinId))
        {
            JSRuntime.InvokeVoidAsync("alert", "Please enter a valid Protein ID.");
            return;
        }
        Article.ProteinData.Add(newProtein);
        newProtein = new ProteinData();
    }

    private async Task RemoveProtein(ProteinData protein)
    {
        if (!await JSRuntime.InvokeAsync<bool>("confirm", "Are you sure you want to delete this protein entry?"))
            return;
        Article.ProteinData.Remove(protein);
    }

    private void RemoveInvalidRecords(string term, int termCategory)
    {
        isLoading = true;
        switch (termCategory)
        {
            case 0: // Protein ID
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.ProteinId != null && p.ProteinId.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 1: // Software Name
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.SoftwareName != null && p.SoftwareName.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 2: // Water Model
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.WaterModel != null && p.WaterModel.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 3: // Force Field
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.ForceField != null && p.ForceField.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 4: // SimulationMethod
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.SimulationMethod != null && p.SimulationMethod.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 5: // Temperature
                if (Article?.ProteinData != null && double.TryParse(term, out double temp))
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.Temperature == temp)
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 6: // Ions
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.Ions != null && p.Ions.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 7: // Ion Concentration
                if (Article?.ProteinData != null && double.TryParse(term, out double ionConcentration))
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.IonConcentration == ionConcentration)
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 8: // Simulation Length
                if (Article?.ProteinData != null && double.TryParse(term, out double simulationLength))
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.SimulationLength == simulationLength)
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 9: // Software Version
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.SoftwareVersion != null && p.SoftwareVersion.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 10: // Residue
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.Residue != null && p.Residue.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
            case 11: // Binder
                if (Article?.ProteinData != null)
                {
                    var toRemove = Article.ProteinData
                        .Where(p => p.Binder != null && p.Binder.Equals(term))
                        .ToList();
                    foreach (var item in toRemove)
                    {
                        Article.ProteinData.Remove(item);
                    }
                }
                break;
        }

        isLoading = false;


    }

    private async Task HighlightText(string term,int termCategory)
    {
        if (termCategory == -1)
        {
            this.termCategory = -1;
        }
        this.termCategory = termCategory;
        searchTerm = term;
        currentHighlightIndex = 0;

        if(termCategory==5 || termCategory == 7 || termCategory == 8)
            replacementValue = Convert.ToDouble(searchTerm);
        else
            replacementValueText = searchTerm;
        ProcessTextForHighlighting();
        UpdateHighlightClasses();

        // Ensure DOM is updated before scrolling
        await InvokeAsync(StateHasChanged);
        await Task.Delay(50); // Give Blazor time to update the DOM

        await ScrollToHighlight();
    }

    private void ProcessTextForHighlighting()
    {
        processedChapters = new();
        highlightCount = 0;

        foreach (var chapter in Article.Chapters)
        {
            var newChapter = new ChapterDisplay { Title = chapter.Title };
            string content = string.Join("\n", chapter.Content.Split('\n'));

            if (!string.IsNullOrEmpty(searchTerm))
            {
                var regex = new Regex(Regex.Escape(searchTerm), ignoreCase ? RegexOptions.IgnoreCase : RegexOptions.None);

                var matches = regex.Matches(content);

                int lastIndex = 0;
                foreach (Match match in matches)
                {
                    if (match.Index > lastIndex)
                    {
                        newChapter.Fragments.Add(new TextFragment
                        {
                            Text = content.Substring(lastIndex, match.Index - lastIndex)
                        });
                    }
                    newChapter.Fragments.Add(new TextFragment
                    {
                        Text = match.Value,
                        IsMatch = true,
                        MatchIndex = highlightCount
                    });
                    highlightCount++;
                    lastIndex = match.Index + match.Length;
                }
                if (lastIndex < content.Length)
                {
                    newChapter.Fragments.Add(new TextFragment
                    {
                        Text = content.Substring(lastIndex)
                    });
                }
            }
            else
            {
                newChapter.Fragments.Add(new TextFragment { Text = content });
            }

            processedChapters.Add(newChapter);
        }
    }

    private async Task NextHighlight()
    {
        if(highlightCount == 0) return;
        currentHighlightIndex = (currentHighlightIndex + 1) % highlightCount;
        UpdateHighlightClasses();


        // Ensure DOM is updated before scrolling
        await InvokeAsync(StateHasChanged);
        await Task.Delay(50); // Give Blazor time to update the DOM

        await ScrollToHighlight();
    }

    private async Task PrevHighlight()
    {
        if (highlightCount == 0) return;
        currentHighlightIndex = (currentHighlightIndex - 1 + highlightCount) % highlightCount;
        UpdateHighlightClasses();

        // Ensure DOM is updated before scrolling
        await InvokeAsync(StateHasChanged);
        await Task.Delay(50); // Give Blazor time to update the DOM

        await ScrollToHighlight();
    }

    private async Task ScrollToHighlight()
    {
        if (currentHighlightIndex < 0) return;

        await JSRuntime.InvokeVoidAsync("scrollToHighlight", 
            currentHighlightIndex.ToString());
    }

    private void UpdateHighlightClasses()
    {
        foreach (var chapter in processedChapters)
        {
            foreach (var fragment in chapter.Fragments)
            {
                fragment.Classes = fragment.IsMatch
                    ? fragment.MatchIndex == currentHighlightIndex 
                        ? "highlight-active" 
                        : "highlight-inactive"
                    : "";
            }
        }
    }

    private async Task DeleteChapter(string chapterTitle)
    {
        await ArticleContentService.DeleteChapterAsync(chapterTitle, Article.Doi);
        Article.Chapters.Remove(Article.Chapters.First(c=>c.Title == chapterTitle));
        processedChapters.RemoveAll(c => c.Title == chapterTitle);
        await InvokeAsync(StateHasChanged);
    }

    private async Task CompleteArticle()
    {
        if (Article == null) return;
        if (Article.ProteinData.Any(p => !p.Approved))
        {
            await JSRuntime.InvokeVoidAsync("alert", "Please approve all protein data before completing the article.");
            return;
        }
        isLoading = true;
        await UpdateArticleProteinData();

        if (ArticlePerProject == null) return;

        await ArticlePerProjectService.CompleteArticlePerProjectByIdArticleDoiAndProjectIdAsync(Article.Doi,ArticlePerProject.ProjectId,ArticlePerProject.Article.ProteinData.ToList(),currentUser.Id);

        ArticlePerProject.IsDiscredited = false;
        ArticlePerProject.DiscreditedReason = string.Empty;
        ArticlePerProject.IsApproved = true;
        ArticlePerProject.DatetimeApproval = DateTime.Now;
        ArticlePerProject.ApprovedById = currentUser.Id;
        isLoading = false;

        StateHasChanged();
        await Close();
    }

    private void ConvertValue(int proteinId, int index, double value)
    {
       var protein = Article.ProteinData.FirstOrDefault(p => p.Id == proteinId);
        if (protein == null) return;

        double convertedValue = value;
        // Update the protein data
        switch (index)
        {
            case 0: protein.Kd = convertedValue; break;
            case 1: protein.KOff = convertedValue; break;
            case 2: protein.KOn = convertedValue; break;
            case 3: protein.FreeBindingEnergy = convertedValue; break;
            default: return; // Invalid index
        }
        StateHasChanged();
    }

    // Supporting classes
    private class ChapterDisplay
    {
        public string Title { get; set; } = "";
        public List<TextFragment> Fragments { get; set; } = new();
    }

    private class TextFragment
    {
        public string Text { get; set; } = "";
        public bool IsMatch { get; set; }
        public int MatchIndex { get; set; } = -1;
        public string Classes { get; set; } = "";
    }


    public async Task Show()
    {
        await (modal?.ShowModal() ?? Task.CompletedTask);

        ProcessTextForHighlighting();
    }

    public async Task Close()
    {
        searchTerm = string.Empty;
        currentHighlightIndex = -1;
        await (modal?.CloseModal() ?? Task.CompletedTask);
    }


    [Inject]
    private IJSRuntime JSRuntime { get; set; }

    [Inject]
    private HttpClient Http { get; set; }
}

    <style>
        /* Highlighting styles */
        .highlight-inactive {
            background-color: #FFEB3B; /* Yellow */
            border-bottom: 2px solid #FFC107;
        }

        .highlight-active {
            background-color: #FFC107; /* Dark yellow */
            border-bottom: 2px solid #FF9800;
        }

        /* Navigation controls */
        .highlight-nav {
            background: white;
            padding: 5px 10px;
            border-radius: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 100;
        }

        /* Modal header adjustments */
        .modal-header {
            flex-wrap: wrap;
            gap: 10px;
            padding-bottom: 10px;
        }

    /* For Bootstrap modals */
    #article-detail-modal .modal-dialog {
        height: 90vh; /* or whatever height you prefer */
        display: flex;
        flex-direction: column;
    }

    #article-detail-modal .modal-content {
        height: 100%;
        display: flex;
        flex-direction: column;
    }

    .sticky-modal-header {
        position: sticky;
        top: 0;
        z-index: 1050; /* Bootstrap modals use z-index 1050 */
        background: white;
        /* Simple border on all sides */
        border: 3px solid #b4b4b4;
        box-shadow: 0 2px 12px rgba(67, 206, 162, 0.08), 0 1.5px 0 rgba(252,87,94,0.08);
        border-radius: 18px;
        transition: border-color 0.3s, box-shadow 0.3s;
    }
    

    .modal-body {
        overflow-y: auto;
        flex: 1;
    }

        /* Table input fields */
        .protein-table input {
            min-width: 80px;
            padding: 0.25rem 0.5rem;
            font-size: 0.9rem;
        }

        /* Full text container */
        .article-fulltext-container {
            padding-top: 40px; /* Space for navigation */
        }

        /* Discredited article styles */
        .discredited-header,
        .discredited-body {
            background-color: #ffcccb !important;
        }
    </style>